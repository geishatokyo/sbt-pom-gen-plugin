package pomgen

import sbt._
import Keys._

import scala.xml.{XML,Elem,NamespaceBinding,Node,Text}
import XML._
import scala.xml.transform._
import java.util.Date
import java.text.SimpleDateFormat
import scala.collection.immutable.HashSet


/**
 * plugin for generating pom
 */ 
object PomGenPlugin extends sbt.Plugin{
  
  object PomGenKeys{
    val pomName = SettingKey[String]("pom-name","set pom filename.default:pom.xml")
    val generatePomTaskKey = TaskKey[Unit]("gen-pom","generate and save pom")
    val composePomTaskKey = TaskKey[Elem]("compose-pom","task:compose genereated pom and existing pom")
    
  }
  
  import PomGenKeys._
  
  
  lazy val pomGenSettings = Seq(
    composePomTask,
    generatePomTask,
    pomName := "pom.xml"
    /*commands ++= Seq(
      genPom
    )*/
  )
  
  
  def backupPom( baseDir : File,pomName : String) = {
    val f = new java.io.File(baseDir,pomName)
    if(f.exists){
      val pomDir = new File(baseDir,"target/pom_backup")
      if(!pomDir.exists){
        pomDir.mkdirs()
      }
      val sufix = new SimpleDateFormat("yyMMddHHmmss").format(new Date)
      val backupDest = new File(pomDir,pomName + "." + sufix)
      LogManager.defaultScreen.info("Save old pom to %s".format(backupDest.getAbsolutePath))
      f.renameTo(backupDest)
    }
  }
  
  def mergeChilren( baseChildren : Seq[Node], m : Seq[Node]) : Seq[Node] = {
    val names = HashSet(baseChildren.collect({
      case e : Elem => e.label
    }) :_*)
    baseChildren ++ Seq(Text("    ")) ++ m.filter( {
      case e : Elem => !names.contains(e.label)
      case n => true
    }).dropWhile( {
      case Text(_) => true
      case _ => false
    })
  }
  
  def findProject(projectId : String) = {
    
  }
  
  case class ScalaVersionPropRep(scalaVersion : String) extends RewriteRule{
    override def transform(node:Node): Seq[Node] = node match{
      case Elem(_,"scala.version",_,_, _@_*) => {
        <scala.version>{scalaVersion}</scala.version>
      }
      case n => n
    }
  }
  
  def replaceScalaVersionProperty( pom : Elem , scalaVersion : String) : Elem = {
    new RuleTransformer(ScalaVersionPropRep(scalaVersion))(pom).asInstanceOf[Elem]
  }
  
  
  
  val composePomTask = composePomTaskKey <<= (scalaVersion,makePom,pomName,baseDirectory) map{ (scalaVersion,generatedPomFile,pomName,baseDir) => {
    val generatedPom = XML.loadFile(generatedPomFile)
    
    def fixNamespace( n : Node, nb : NamespaceBinding) : Node = {
      n match{
        case Elem( prefix,label,metaData,_,children@_*) => {
          Elem(prefix,label,metaData,nb, children.map(fixNamespace(_,nb)) :_*)
        }
        case n => n
      }
    }
    val f = new java.io.File(baseDir,pomName)
    
    val basePom = if(f.exists()){
      XML.loadFile(f)
    }else{
      LogManager.defaultScreen.info(pomName + " is not found.Copy pom generated by make-pom")
      TemplateXML.template
    }
    
    val composed = basePom match{
      case Elem(prefix,label , metaData , nb , children@_*) => {
        val genChildren = fixNamespace(generatedPom,nb).child
        Elem(prefix, label, metaData, nb, mergeChilren(genChildren,children) :_*)
      }
      case _ => {
        println("can't find base pom")
        generatedPom
      }
    }
    replaceScalaVersionProperty(composed,scalaVersion)
  }}
  
  val generatePomTask = generatePomTaskKey <<= (composePomTaskKey,pomName,baseDirectory) map{ (composedPom ,pomName, baseDir) => {
    
    backupPom(baseDir,pomName)
    
    XML.save(new File(baseDir,pomName).getAbsolutePath,composedPom)
  
  }}
    
  
  /*
  lazy val genPom = Command.command("gen-pom") { state =>
    println("generate pom!")
    state
  }*/
}